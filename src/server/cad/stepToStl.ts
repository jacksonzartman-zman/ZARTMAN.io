import { createHash } from "crypto";
import { createRequire } from "module";
import path from "node:path";
import type { OcctImportModule, ReadStepResult } from "occt-import-js";

export type StepPreviewKey = {
  sourceBucket: string;
  sourcePath: string;
  sourceFileName?: string | null;
};

export type StepToStlConversionResult = {
  stl: Buffer;
  triangles: number;
  meshes: number;
};

const PREVIEW_PREFIX = "step-stl/v1";

function safeTrim(value: unknown): string {
  return typeof value === "string" ? value.trim() : "";
}

function sanitizeFileStem(value: string): string {
  const raw = value.trim().replace(/\.(step|stp)$/i, "");
  const cleaned = raw.replace(/[^a-zA-Z0-9._-]+/g, "-").replace(/-+/g, "-").replace(/(^-+|-+$)/g, "");
  return cleaned || "preview";
}

function shortHash(input: string): string {
  return createHash("sha256").update(input).digest("hex").slice(0, 24);
}

export function buildStepStlPreviewPath(key: StepPreviewKey): string {
  const bucket = safeTrim(key.sourceBucket);
  const path = safeTrim(key.sourcePath).replace(/^\/+/, "");
  const fileName = safeTrim(key.sourceFileName) || (path.split("/").pop() ?? "");
  const stem = sanitizeFileStem(fileName || "preview");
  const h = shortHash(`${bucket}\n${path}`);
  // Deterministic + human-readable (hash anchors uniqueness).
  return `${PREVIEW_PREFIX}/${h}-${stem}.stl`;
}

function safeArrayLikeLength(value: unknown): number {
  const n = (value as any)?.length;
  return typeof n === "number" && Number.isFinite(n) && n >= 0 ? n : 0;
}

function readArrayLikeNumber(arr: ArrayLike<number>, index: number): number {
  const v = (arr as any)[index];
  return typeof v === "number" ? v : Number(v);
}

function computeNormal(
  ax: number,
  ay: number,
  az: number,
  bx: number,
  by: number,
  bz: number,
  cx: number,
  cy: number,
  cz: number,
): [number, number, number] {
  const abx = bx - ax;
  const aby = by - ay;
  const abz = bz - az;
  const acx = cx - ax;
  const acy = cy - ay;
  const acz = cz - az;
  const nx = aby * acz - abz * acy;
  const ny = abz * acx - abx * acz;
  const nz = abx * acy - aby * acx;
  const len = Math.hypot(nx, ny, nz) || 0;
  if (!len) return [0, 0, 0];
  return [nx / len, ny / len, nz / len];
}

function encodeBinaryStlFromOcctMeshes(result: ReadStepResult): StepToStlConversionResult {
  const meshes = Array.isArray(result.meshes) ? result.meshes : [];
  let triangles = 0;

  for (const mesh of meshes) {
    const pos = mesh?.attributes?.position?.array as ArrayLike<number> | undefined;
    const idx = mesh?.index?.array as ArrayLike<number> | undefined;
    const posLen = safeArrayLikeLength(pos);
    const idxLen = safeArrayLikeLength(idx);
    if (!pos || posLen < 9) continue;
    if (idx && idxLen >= 3) triangles += Math.floor(idxLen / 3);
    else triangles += Math.floor(posLen / 9);
  }

  if (triangles <= 0) {
    return { stl: Buffer.from(new Uint8Array(0)), triangles: 0, meshes: meshes.length };
  }

  // Binary STL: 80-byte header + uint32 triangle count + triangles * 50 bytes.
  const out = Buffer.allocUnsafe(84 + triangles * 50);
  out.fill(0, 0, 80);
  out.write("generated by zartman.io", 0, "ascii");
  out.writeUInt32LE(triangles >>> 0, 80);

  let offset = 84;
  const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  const writeF32 = (v: number) => {
    view.setFloat32(offset, Number.isFinite(v) ? v : 0, true);
    offset += 4;
  };
  const writeU16 = (v: number) => {
    view.setUint16(offset, v & 0xffff, true);
    offset += 2;
  };

  for (const mesh of meshes) {
    const pos = mesh?.attributes?.position?.array as ArrayLike<number> | undefined;
    const idx = mesh?.index?.array as ArrayLike<number> | undefined;
    const posLen = safeArrayLikeLength(pos);
    const idxLen = safeArrayLikeLength(idx);
    if (!pos || posLen < 9) continue;

    if (idx && idxLen >= 3) {
      for (let i = 0; i + 2 < idxLen; i += 3) {
        const i0 = readArrayLikeNumber(idx, i) * 3;
        const i1 = readArrayLikeNumber(idx, i + 1) * 3;
        const i2 = readArrayLikeNumber(idx, i + 2) * 3;
        if (i0 + 2 >= posLen || i1 + 2 >= posLen || i2 + 2 >= posLen) continue;

        const ax = readArrayLikeNumber(pos, i0);
        const ay = readArrayLikeNumber(pos, i0 + 1);
        const az = readArrayLikeNumber(pos, i0 + 2);
        const bx = readArrayLikeNumber(pos, i1);
        const by = readArrayLikeNumber(pos, i1 + 1);
        const bz = readArrayLikeNumber(pos, i1 + 2);
        const cx = readArrayLikeNumber(pos, i2);
        const cy = readArrayLikeNumber(pos, i2 + 1);
        const cz = readArrayLikeNumber(pos, i2 + 2);

        const [nx, ny, nz] = computeNormal(ax, ay, az, bx, by, bz, cx, cy, cz);
        writeF32(nx);
        writeF32(ny);
        writeF32(nz);
        writeF32(ax);
        writeF32(ay);
        writeF32(az);
        writeF32(bx);
        writeF32(by);
        writeF32(bz);
        writeF32(cx);
        writeF32(cy);
        writeF32(cz);
        writeU16(0);
      }
    } else {
      for (let i = 0; i + 8 < posLen; i += 9) {
        const ax = readArrayLikeNumber(pos, i);
        const ay = readArrayLikeNumber(pos, i + 1);
        const az = readArrayLikeNumber(pos, i + 2);
        const bx = readArrayLikeNumber(pos, i + 3);
        const by = readArrayLikeNumber(pos, i + 4);
        const bz = readArrayLikeNumber(pos, i + 5);
        const cx = readArrayLikeNumber(pos, i + 6);
        const cy = readArrayLikeNumber(pos, i + 7);
        const cz = readArrayLikeNumber(pos, i + 8);

        const [nx, ny, nz] = computeNormal(ax, ay, az, bx, by, bz, cx, cy, cz);
        writeF32(nx);
        writeF32(ny);
        writeF32(nz);
        writeF32(ax);
        writeF32(ay);
        writeF32(az);
        writeF32(bx);
        writeF32(by);
        writeF32(bz);
        writeF32(cx);
        writeF32(cy);
        writeF32(cz);
        writeU16(0);
      }
    }
  }

  return { stl: out, triangles, meshes: meshes.length };
}

function resolveOcctWasmPath(requestedPath: string): string {
  // `occt-import-js` is an Emscripten build; this helps it find the wasm file in Node.
  // Important: avoid referencing the `.wasm` file via an import/require specifier, or webpack will try to bundle it.
  const basename = requestedPath.split("/").pop() ?? requestedPath;
  if (!basename.endsWith(".wasm")) return basename;

  try {
    const require = createRequire(import.meta.url);
    const jsEntry = require.resolve("occt-import-js");
    return path.join(path.dirname(jsEntry), basename);
  } catch {
    // Fall back: let the module attempt its default resolution.
    return basename;
  }
}

export async function convertStepToBinaryStl(stepBytes: Uint8Array): Promise<StepToStlConversionResult> {
  const occtImportJs = (await import("occt-import-js")).default;
  const occt: OcctImportModule = await occtImportJs({
    locateFile: (path) => resolveOcctWasmPath(path),
  });

  const readResult = occt.ReadStepFile(stepBytes, {});
  if (!readResult?.success) {
    return { stl: Buffer.from(new Uint8Array(0)), triangles: 0, meshes: 0 };
  }

  return encodeBinaryStlFromOcctMeshes(readResult);
}

