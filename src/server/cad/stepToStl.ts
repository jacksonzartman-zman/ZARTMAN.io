import { createHash } from "crypto";
import { createRequire } from "module";
import fs from "node:fs";
import path from "node:path";
import type { OcctImportModule, ReadStepResult } from "occt-import-js";

export type StepPreviewKey = {
  sourceBucket: string;
  sourcePath: string;
  sourceFileName?: string | null;
};

export type StepToStlConversionResult = {
  stl: Buffer;
  triangles: number;
  meshes: number;
};

const PREVIEW_PREFIX = "step-stl/v1";

let didLogOcctWasm = false;
let cachedOcctPaths: { jsEntry: string; distDir: string; wasmPath: string } | null = null;
let cachedWasmBinary: Uint8Array | null = null;

function safeTrim(value: unknown): string {
  return typeof value === "string" ? value.trim() : "";
}

function sanitizeFileStem(value: string): string {
  const raw = value.trim().replace(/\.(step|stp)$/i, "");
  const cleaned = raw.replace(/[^a-zA-Z0-9._-]+/g, "-").replace(/-+/g, "-").replace(/(^-+|-+$)/g, "");
  return cleaned || "preview";
}

function shortHash(input: string): string {
  return createHash("sha256").update(input).digest("hex").slice(0, 24);
}

export function buildStepStlPreviewPath(key: StepPreviewKey): string {
  const bucket = safeTrim(key.sourceBucket);
  const path = safeTrim(key.sourcePath).replace(/^\/+/, "");
  const fileName = safeTrim(key.sourceFileName) || (path.split("/").pop() ?? "");
  const stem = sanitizeFileStem(fileName || "preview");
  const h = shortHash(`${bucket}\n${path}`);
  // Deterministic + human-readable (hash anchors uniqueness).
  return `${PREVIEW_PREFIX}/${h}-${stem}.stl`;
}

function safeArrayLikeLength(value: unknown): number {
  const n = (value as any)?.length;
  return typeof n === "number" && Number.isFinite(n) && n >= 0 ? n : 0;
}

function readArrayLikeNumber(arr: ArrayLike<number>, index: number): number {
  const v = (arr as any)[index];
  return typeof v === "number" ? v : Number(v);
}

function computeNormal(
  ax: number,
  ay: number,
  az: number,
  bx: number,
  by: number,
  bz: number,
  cx: number,
  cy: number,
  cz: number,
): [number, number, number] {
  const abx = bx - ax;
  const aby = by - ay;
  const abz = bz - az;
  const acx = cx - ax;
  const acy = cy - ay;
  const acz = cz - az;
  const nx = aby * acz - abz * acy;
  const ny = abz * acx - abx * acz;
  const nz = abx * acy - aby * acx;
  const len = Math.hypot(nx, ny, nz) || 0;
  if (!len) return [0, 0, 0];
  return [nx / len, ny / len, nz / len];
}

function encodeBinaryStlFromOcctMeshes(result: ReadStepResult): StepToStlConversionResult {
  const meshes = Array.isArray(result.meshes) ? result.meshes : [];
  let triangles = 0;

  for (const mesh of meshes) {
    const pos = mesh?.attributes?.position?.array as ArrayLike<number> | undefined;
    const idx = mesh?.index?.array as ArrayLike<number> | undefined;
    const posLen = safeArrayLikeLength(pos);
    const idxLen = safeArrayLikeLength(idx);
    if (!pos || posLen < 9) continue;
    if (idx && idxLen >= 3) triangles += Math.floor(idxLen / 3);
    else triangles += Math.floor(posLen / 9);
  }

  if (triangles <= 0) {
    return { stl: Buffer.from(new Uint8Array(0)), triangles: 0, meshes: meshes.length };
  }

  // Binary STL: 80-byte header + uint32 triangle count + triangles * 50 bytes.
  const out = Buffer.allocUnsafe(84 + triangles * 50);
  out.fill(0, 0, 80);
  out.write("generated by zartman.io", 0, "ascii");
  out.writeUInt32LE(triangles >>> 0, 80);

  let offset = 84;
  const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  const writeF32 = (v: number) => {
    view.setFloat32(offset, Number.isFinite(v) ? v : 0, true);
    offset += 4;
  };
  const writeU16 = (v: number) => {
    view.setUint16(offset, v & 0xffff, true);
    offset += 2;
  };

  for (const mesh of meshes) {
    const pos = mesh?.attributes?.position?.array as ArrayLike<number> | undefined;
    const idx = mesh?.index?.array as ArrayLike<number> | undefined;
    const posLen = safeArrayLikeLength(pos);
    const idxLen = safeArrayLikeLength(idx);
    if (!pos || posLen < 9) continue;

    if (idx && idxLen >= 3) {
      for (let i = 0; i + 2 < idxLen; i += 3) {
        const i0 = readArrayLikeNumber(idx, i) * 3;
        const i1 = readArrayLikeNumber(idx, i + 1) * 3;
        const i2 = readArrayLikeNumber(idx, i + 2) * 3;
        if (i0 + 2 >= posLen || i1 + 2 >= posLen || i2 + 2 >= posLen) continue;

        const ax = readArrayLikeNumber(pos, i0);
        const ay = readArrayLikeNumber(pos, i0 + 1);
        const az = readArrayLikeNumber(pos, i0 + 2);
        const bx = readArrayLikeNumber(pos, i1);
        const by = readArrayLikeNumber(pos, i1 + 1);
        const bz = readArrayLikeNumber(pos, i1 + 2);
        const cx = readArrayLikeNumber(pos, i2);
        const cy = readArrayLikeNumber(pos, i2 + 1);
        const cz = readArrayLikeNumber(pos, i2 + 2);

        const [nx, ny, nz] = computeNormal(ax, ay, az, bx, by, bz, cx, cy, cz);
        writeF32(nx);
        writeF32(ny);
        writeF32(nz);
        writeF32(ax);
        writeF32(ay);
        writeF32(az);
        writeF32(bx);
        writeF32(by);
        writeF32(bz);
        writeF32(cx);
        writeF32(cy);
        writeF32(cz);
        writeU16(0);
      }
    } else {
      for (let i = 0; i + 8 < posLen; i += 9) {
        const ax = readArrayLikeNumber(pos, i);
        const ay = readArrayLikeNumber(pos, i + 1);
        const az = readArrayLikeNumber(pos, i + 2);
        const bx = readArrayLikeNumber(pos, i + 3);
        const by = readArrayLikeNumber(pos, i + 4);
        const bz = readArrayLikeNumber(pos, i + 5);
        const cx = readArrayLikeNumber(pos, i + 6);
        const cy = readArrayLikeNumber(pos, i + 7);
        const cz = readArrayLikeNumber(pos, i + 8);

        const [nx, ny, nz] = computeNormal(ax, ay, az, bx, by, bz, cx, cy, cz);
        writeF32(nx);
        writeF32(ny);
        writeF32(nz);
        writeF32(ax);
        writeF32(ay);
        writeF32(az);
        writeF32(bx);
        writeF32(by);
        writeF32(bz);
        writeF32(cx);
        writeF32(cy);
        writeF32(cz);
        writeU16(0);
      }
    }
  }

  return { stl: out, triangles, meshes: meshes.length };
}

function resolveOcctPaths(): { jsEntry: string; distDir: string; wasmPath: string } {
  if (cachedOcctPaths) return cachedOcctPaths;

  // IMPORTANT: do NOT use require.resolve() here. When bundled by Next/webpack,
  // require.resolve("...") can be rewritten into a numeric module id, which then
  // breaks downstream path operations like path.dirname().
  //
  // Instead, compute absolute on-disk paths relative to the runtime working dir
  // (Vercel lambdas run with CWD at the bundle root that contains node_modules).
  const distDir = path.join(process.cwd(), "node_modules", "occt-import-js", "dist");
  const jsEntry = path.join(distDir, "occt-import-js.js");
  const wasmPath = path.join(distDir, "occt-import-js.wasm");
  cachedOcctPaths = { jsEntry, distDir, wasmPath };
  return cachedOcctPaths;
}

export async function convertStepToBinaryStl(
  stepBytes: Uint8Array,
  opts?: { rid?: string },
): Promise<StepToStlConversionResult> {
  const rid = opts?.rid ?? "no-rid";
  const { jsEntry, distDir, wasmPath } = resolveOcctPaths();

  // Load the wasm once and pass wasmBinary so we don't rely on locateFile().
  if (!cachedWasmBinary) {
    const exists = fs.existsSync(wasmPath);
    if (!exists) {
      throw new Error(`occt-import-js wasm missing at resolved path: ${wasmPath}`);
    }
    try {
      const buf = fs.readFileSync(wasmPath);
      cachedWasmBinary = new Uint8Array(buf);
    } catch (err) {
      throw new Error(`[stepToStl] failed to read wasmBinary at ${wasmPath}: ${String(err)}`);
    }
  }

  if (!didLogOcctWasm) {
    didLogOcctWasm = true;
    console.log("[stepToStl] occt runtime load", {
      rid,
      jsEntry,
      jsEntryType: typeof jsEntry,
      wasmPath,
      wasmPathType: typeof wasmPath,
      wasmExists: fs.existsSync(wasmPath),
      wasmBytes: cachedWasmBinary?.byteLength ?? 0,
      distDir,
    });
  }

  // IMPORTANT: use runtime require() (not `import()`) to avoid webpack bundling.
  const require = createRequire(import.meta.url);
  let occtFactoryModule: unknown;
  try {
    // Prefer the dist entry (adjacent to wasm).
    // Use a string literal to avoid webpack treating this as a dynamic require.
    occtFactoryModule = require("occt-import-js/dist/occt-import-js.js");
  } catch {
    // Fallback to package entry if dist path changes.
    occtFactoryModule = require("occt-import-js");
  }
  const occtImportFactory =
    (occtFactoryModule as any)?.default && typeof (occtFactoryModule as any).default === "function"
      ? (occtFactoryModule as any).default
      : occtFactoryModule;
  if (typeof occtImportFactory !== "function") {
    throw new Error(`[stepToStl] occt-import-js factory not a function (typeof=${typeof occtImportFactory})`);
  }

  // `occt-import-js` supports `wasmBinary` at runtime, but its types may not include it.
  const occt: OcctImportModule = await (occtImportFactory as unknown as (opts: { wasmBinary: Uint8Array }) => Promise<OcctImportModule>)(
    {
      wasmBinary: cachedWasmBinary,
    },
  );

  const readResult = occt.ReadStepFile(stepBytes, {});
  if (!readResult?.success) {
    return { stl: Buffer.from(new Uint8Array(0)), triangles: 0, meshes: 0 };
  }

  return encodeBinaryStlFromOcctMeshes(readResult);
}

